Perfect üëç ‚Äî this is the right next step.
We‚Äôll run FastAPI in Podman and connect it to the Redis Podman container, container-to-container.

I‚Äôll keep it clean, minimal, and correct.


---

üß† Target Architecture

[ Producer.py (host or container) ]
                |
                v
        [ Redis container ]
                |
                v
        [ FastAPI container ]
                |
                v
             Clients

Key point: FastAPI and Redis talk over a Podman network, not localhost.


---

1Ô∏è‚É£ Create a Podman network (IMPORTANT)

Containers should communicate using a user-defined network.

As mycompute:

podman network create redis-net

Verify:

podman network ls


---

2Ô∏è‚É£ Run Redis container on that network

podman run -d \
  --name redis \
  --network redis-net \
  -p 6379:6379 \
  -v redis-data:/data \
  redis redis-server --appendonly yes

üìå Redis container name = redis
This name becomes the hostname inside the network.


---

3Ô∏è‚É£ FastAPI application code

Project structure

fastapi_app/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ Containerfile


---

requirements.txt

fastapi
uvicorn
redis


---

main.py

from fastapi import FastAPI
import redis
import json

app = FastAPI()

# IMPORTANT: host is "redis", not localhost
r = redis.Redis(
    host="redis",
    port=6379,
    decode_responses=True
)

@app.get("/data")
def get_data():
    data = r.get("latest_data")

    if not data:
        return {"status": "no data in redis"}

    return {
        "source": "redis",
        "data": json.loads(data)
    }


---

4Ô∏è‚É£ Create Containerfile (Dockerfile)

Containerfile

FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY main.py .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]


---

5Ô∏è‚É£ Build FastAPI image

From inside fastapi_app/:

podman build -t fastapi-redis .

Verify:

podman images


---

6Ô∏è‚É£ Run FastAPI container

podman run -d \
  --name fastapi \
  --network redis-net \
  -p 8000:8000 \
  fastapi-redis

Check:

podman ps
podman logs fastapi


---

7Ô∏è‚É£ Test FastAPI

curl http://localhost:8000/data

Initially:

{"status":"no data in redis"}


---

8Ô∏è‚É£ Push data into Redis (Producer)

If your producer is on the host, update it like this:

r = redis.Redis(host="localhost", port=6379, decode_responses=True)

Push data:

python producer.py

OR manually test:

podman exec -it redis redis-cli
SET latest_data '{"value":123,"time":"now"}'

Then hit API again:

curl http://localhost:8000/data

You‚Äôll get:

{
  "source": "redis",
  "data": {
    "value": 123,
    "time": "now"
  }
}


---

üîë Critical Networking Rule (Remember This)

Where code runs	Redis host

Host machine	localhost
Inside container	redis
Different container	redis


Never use localhost between containers.


---

9Ô∏è‚É£ Make FastAPI auto-start (optional, recommended)

Generate systemd unit:

podman generate systemd --name fastapi --files --new

Enable it:

mkdir -p ~/.config/systemd/user
mv container-fastapi.service ~/.config/systemd/user/
systemctl --user daemon-reload
systemctl --user enable --now container-fastapi.service


---

‚úÖ What you have now

‚úî Redis container (persistent)
‚úî FastAPI container
‚úî Shared Podman network
‚úî Cached reads from Redis
‚úî Clean separation of concerns

This is production-grade architecture.


---

Next logical upgrades (tell me which one you want)

1. Run producer as a container


2. Add TTL / cache expiry


3. Add Redis connection pooling


4. Add health checks


5. Secure Redis (password)


6. Add FastAPI background task


7. Add docker-compose‚Äìstyle setup (podman-compose)



You‚Äôre building this the right way.
